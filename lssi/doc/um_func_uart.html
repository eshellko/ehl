<html>
   <style> pre.small {line-height: 0.5; font-weight:bold; color: #FF00FF; }</style>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Функционирование (UART)</title>
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <h2>Функционирование (UART)</h2>

      <p>Выбор режима приема/передачи происходит через регистр управления <b>CTRL</b>. Отслеживание состояния трансферов осуществляется через регистр состояния приемо-передатчиков <b>STAT</b>. Отслеживание состояния буферов осуществляется через регистр состояния буферов <b>FSR</b>.</p>

      <h3>Передача через UART</h3>
      <p>Передача через UART инициируется, если в буфере передатчика находятся данные (<b>FSR.TxEmpty=b'0</b>), и разрешена передача (<b>CTRL.TE</b>=b'1). Начало передачи сигнализируется установкой бита <b>STAT.TxIP</b>. Передача заканчивается, после опустошения буфера (<b>FSR.TxEmpty</b>=b'1), сбросом бита <b>STAT.TxIP</b>.</p>

      <h3>Прием через UART</h3>
      <p>Прием начинается после обнаружения СТАРТ-бита на линии RX и сигнализируется установкой бита <b>STAT.RxIP</b>. Прием заканчивается после обнаружения СТОП-бита сбросом бита <b>STAT.RxIP</b>.</p>
      <p>Принятый байт записывается в буфер приемника. Байт не  будет записан, если выполнено хотя бы одно из трех условий:</p>
      <li>Запись в буфер приемника приведет к его переполнению (устанавливается <b>FCR.RxOverflow</b>).</li>
      <li>В принятом байте разрешена проверка четности (<b>CFG.PAR</b>=b'1) и бит четности в принятом байте не совпадает (устанавливается <b>STAT.PE</b>).</li>
<!-- TODO: Добавить  информацию о том, какая полярность у бита четности. -->
      <li>Во время приема СТОП-бита линия RX имеет значение логического нуля (устанавливается <b>STAT.FE</b>).</li>
      <p>Изменение значения <b>CFG.PE</b>, <b>CFG.TBO</b> в процессе приема/передачи может привести к неправильному функционированию устройства. Перед изменением данных бит следует остановить приемо-передатчик установив <b>CTRL.TE</b>.<!-- TODO: Который находится в том же регистре!!! Отсюда вопрос, а одновременно это сделать можно, ответ-да , поскольку данные будут отброшены!--></p>
      <p>Передача может быть приостановлена сбросом <b>CTRL.TE</b>. Вне зависимости от момента сброса, передача текущего байта (если она была начата) будет завершена, а следующая передача не начнется до установки бита <b>CTRL.TE</b>.</p>

      <h3>Обмен с сокращенной длиной байта</h3>
      <p>При использовании режима передачи с длиной байта менее 8 бит, передача данных между блоками происходит следующим образом:</p>
      <li>Данные в буфер передатчика записываются через <b>PWDATA</b> по 8 бит.</li>
      <li>Данные из буфера записываются в передатчик в виде 8-битного байта.</li>
      <li>Передается по UART только указанное в <b>CFG.BL</b> количество бит. Передаваемые биты определяются битом <b>CFG.TBO</b>. Оставшиеся биты отбрасываются.</li>
      <li>Принимается по UART только указанное в <b>CFG.BL</b> количество бит. Биты-дополнения, увеличивающие длину принятого байта до 8 бит, перед записью в буфер приемника обнуляются. Положение бит-дополнений в байте определяется битом <b>CFG.TBO</b>.</li>
      <li>Данные из буфера приемника читаются через <b>PRDATA</b> с обнуленными битами-дополнениями.</li>

      <h3>Режим Flow Control</h3>
      <p>
         Режим Flow Control используется, чтобы избежать переполнения буфера приемника.
         Сигналы <b>sck_rts_o</b>/<b>ts0_cts_i</b> информируют устройство на другом конце интерфейса о готовности принять очередную порцию данных.
         Активация режима управлется в регистре <b>UFCR</b>.
      </p>
      <p><a name="UFCR"></a><b style="color: #0000CC">UFCR [0x0D] : </b>Регистр аппаратного контроля UART.</p>
      <table summary="UFCR" cellpadding="4" width="100%" border="1" cellspacing="0" rules="all">
         <colgroup><col><col><col><col><col></colgroup>
         <thead>
            <tr bgcolor="#C0C0C0">
               <th>Биты</th>
               <th>Название</th>
               <th>Описание</th>
               <th>Доступ</th>
               <th>Начальное значение</th>
            </tr>
         </thead>
         <tbody>
            <tr> <td>7:3</td> <td>-</td> <td><b>Резерв</b></td> <td>R</td> <td>0</td> </tr>
            <tr> <td>2</td> <td>CTS</td> <td>Текущее значение на выводе <b>ss0_cts_i</b>. Значение с учетом 2-тактового синхронизатора. В режиме SPI равен 0.</td> <td>R</td> <td>0</td> </tr>
            <tr> <td>1</td> <td>CTSEN</td> <td>Разрешение проверки <b>ts0_cts_i</b> перед отправкой данных:<li>0 - запрещена;</li><li>1 - разрешена.</li></td> <td>R/W</td> <td>0</td> </tr>
            <tr> <td>0</td> <td>RTSEN</td> <td>Разрешение генерации сигнала <b>sck_rts_o</b>:<li>0 - запрещена, вывод равен 0;</li><li>1 - разрешена, <b>sck_rts_o</b> становится равен 1, если в FIFO приемника недостаточно места.</li></td> <td>R/W</td> <td>0</td> </tr>
         </tbody>
      </table>

      <p>Аппаратное управление <b>sck_rts_o</b> осуществляется по следующему алгоритму. Сигнал устанавливается в 1, требуя прекращения активности на линии, в следующих случаях (при <b>UFCR.RTSEN</b> равном 1):</p>
      <li>Буфер приемника заполнен - <b>FCR.RxFull</b> равен 1.</li>
      <li>Буфер приемника почти заполнен после обнаружения СТАРТ бита в принимаемом слове - <b>FCR.RxAlmostFull</b> равен 1.</li>
      <p><b>sck_rts_o</b> сбрасывается, если нет приема (<b>STAT.RxIP</b> = 0) и в буфер не заполнен (<b>FCR.RxFull</b> = 0).</p>

      <p>Аппаратный контроль <b>ts0_cts_i</b> осуществляется по следующему алгоритму (при <b>UFCR.CTSEN</b> равном 1):</p>
      <li>Если сигнал <b>ts0_cts_i</b> равен логической единице, передатчик закончит текущую передачу (если она имела место).</li>
      <li>Последующая передача начнется при наличии данных в буфере передатчика, если установлен бит <b>CTRL.TE</b> и <b>ts0_cts_i</b> равен нулю.</li>

      <h3>Захват данных</h3>
      <p>В зависимости от параметра <b>TICKS_TO_BIT</b> контроллер отсчитывает различное количество тактов от стартового бита, чтобы оказаться в середине битового интервала.</p>
      <p>Момент захвата данных помечен <b>X</b>.</p>
<!--       <p>Момент захвата данных помечен <b>Y</b> и <b>X</b>.</p> -->
<!--      <p>
         Поскольку при делении интервала на 4 / 8 / 16 момент захвата смещен к одному из фронтов входных данных, контроллер проводит 2 захвата на теоретически одинаковом расстоянии от центра битового интервала.
         В случае, если захваченные значения отличаются друг от друга контроллер сигнализирует ошибку Frame Error.
      </p>-->
<pre class="small">                  _______________________________                                 _________________________________</pre>
<pre class="small"> SIN                                             |_______________________________|                                 </pre>
<pre class="small"> TICKS_TO_BIT=0   |       |       |       |       |       |       |       |       |       |       |       |        </pre>
<pre class="small">                                  X                               X                               X                </pre>
<!-- <pre class="small">                          Y       X                       Y       X                       Y       X                </pre> -->
<pre class="small"> TICKS_TO_BIT=1   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    </pre>
<pre class="small">                                  X                               X                               X                </pre>
<!-- <pre class="small">                              Y   X                           Y   X                           Y   X                </pre> -->
<pre class="small"> TICKS_TO_BIT=2   | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |  </pre>
<pre class="small">                                  X                               X                               X                </pre>
<!-- <pre class="small">                                Y X                             Y X                             Y X                </pre> -->

   </body>
</html>
