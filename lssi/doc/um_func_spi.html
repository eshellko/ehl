<html>
   <style> pre.small {line-height: 0.5; font-weight:bold; color: #FF00FF; }</style>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Функционирование (SPI)</title>
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
   <h2>Функционирование (SPI)</h2>

   <p>
      Здесь и далее под трансфером понимается передача данных из буфера <b>fifo_tx</b> на выход <b>MOSI</b>/<b>MISO</b> и прием данных с <b>MISO</b>/<b>MOSI</b> в буфер <b>fifo_rx</b>.
      Прием и передача происходят одновременно с использованием тактового сигнала для ведомого устройства <b>SCK</b>.
   </p>
   <p>
      Выбор режима трансфера осуществляется через регистр конфигурирования <b>CFG</b>.
      Разрешение работы задается в регистре <b>CTRL</b>.
      Управление выбором ведомого устройства осуществляется через регистр <b>TSR</b>.
      Отслеживание заполнения буферов осуществляется через регистр состояния <b>FSR</b>.
   </p>

   <h3>Фаза и полярность трансфера</h3>
   <p>
      Биты <b>CFG.PHA</b> и <b>CFG.POL</b> определяют фазу и полярность тактового сигнала при трансфере.
      Соотношение сигналов <b>MOSI</b>/<b>MISO</b> и <b>SCK</b> для режимов Controller и Target идентично.
   </p>
   <table summary="spi_modes" cellpadding="4" width="0%" border="1" cellspacing="0" rules="all">
      <colgroup><col><col><col></colgroup>
      <thead>
         <tr bgcolor="#C0C0C0"> <th>CFG.POL</th> <th>CFG.PHA</th> <th>Описание</th> </tr>
      </thead>
      <tbody>
         <tr> <td>0</td> <td>0</td> <td><p>В отсутствии трансфера <b>SCK</b>=b'0.</p><p>Данные выдвигаются по падающему фронту <b>SCK</b>, захватываются по нарастающему фронту <b>SCK</b>.</p></td> </tr>
         <tr> <td>0</td> <td>1</td> <td><p>В отсутствии трансфера <b>SCK</b>=b'0.</p><p>Данные выдвигаются по нарастающему фронту <b>SCK</b>, захватываются по падающему фронту <b>SCK</b>.</p></td> </tr>
         <tr> <td>1</td> <td>0</td> <td><p>В отсутствии трансфера <b>SCK</b>=b'1.</p><p>Данные выдвигаются по нарастающему фронту <b>SCK</b>, захватываются по падающему фронту <b>SCK</b>.</p></td> </tr>
         <tr> <td>1</td> <td>1</td> <td><p>В отсутствии трансфера <b>SCK</b>=b'1.</p><p>Данные выдвигаются по падающему фронту <b>SCK</b>, захватываются по нарастающему фронту <b>SCK</b>.</p></td> </tr>
      </tbody>
   </table>

   <p>&nbsp;</p>
   <img src="um_mode.png" width="70%">
   <p>&nbsp;</p>

   <p><a name="TSR"></a><b style="color: #0000CC">TSR [0x03] : </b>Регистр управления сигналами выбора Target.</p>
   <table summary="Fields for Register: TSR" cellpadding="4" width="100%" border="1" cellspacing="0" rules="all">
      <colgroup><col><col><col><col><col></colgroup>
      <thead>
         <tr bgcolor="#C0C0C0">
            <th>Биты</th>
            <th>Название</th>
            <th>Описание</th>
            <th>Доступ</th>
            <th>Начальное значение</th>
         </tr>
      </thead>
      <tbody>
         <tr>
            <td>7:1</td>
            <td>TS</td>
            <td>
               <p><b>Target Select</b>. Выбор Target устройства, связанного с данным битом регистра.</p>
               <p>Акутальное количество бит определяется параметром <b>TS_WIDTH</b>. В случае отсутствия бита, значение равно 0.</p>
            </td>
            <td>R/W</td>
            <td>0x7F</td>
         </tr>
         <tr>
            <td>0</td>
            <td>TS0</td>
            <td>
               <p><b>Target Select 0</b>. При записи аналогичен старшим битам регистра. При чтении в режиме Controller (<b>CFG.SM</b>=b'0) равен записанному в нему значению, в режиме Target равен значению на выводе <b>ts0_cts_i</b> с учетом задержки на синхронизацию.</p>
			  <li>0 - Устройство активно в режиме Target;</li>
			  <li>1 - устройство неактивно в режиме Target.</li>
            </td>
            <td>R/W</td>
            <td>1</td>
         </tr>
      </tbody>
   </table>

   <h3>Режим Controller</h3>
   <p>
      Трансфер через SPI осуществляется, если в буфере передатчика находятся данные (<b>FSR.TxEmpty</b>=b'0), и разрешена передача (<b>CTRL.TE</b>=b'1).
      Начало трансфера сигнализируется установкой бита <b>STAT.TIP</b>.
      Когда последний байт из буфера <b>fifo_tx</b> переписывается в передатчик <b>spi_controller</b>, устанавливается бит <b>FSR.TxEmpty</b>.
      Трансфер заканчивается после передачи последнего байта, бит <b>STAT.TIP</b> сбрасывается.
   </p>
   <p>
      Изменение значения <b>CFG.PHA</b>, <b>CFG.POL</b> и <b>CFG.TBO</b> в процессе трансфера может привести к неправильному функционированию устройства.
   </p>
   <p>
      Трансфер может быть приостановлен сбросом <b>CTRL.TE</b>.
      Вне зависимости от момента сброса, передача текущего байта (если она была начата) будет завершена, а следующая передача не начнется до установки бита <b>CTRL.TE</b>.
   </p>
<pre class="small">                     __    __    __    __    __    __    __    __       __    __    __    __    __    __    __    __       </pre>
<pre class="small"> SCK         : _____|  |__|  |__|  |__|  |__|  |__|  |__|  |__|  |_____|  |__|  |__|  |__|  |__|  |__|  |__|  |__|  |______</pre>
<pre class="small">                                                            _____     ____       _____       ___________       _____       </pre>
<pre class="small"> MOSI        : ____________________________________________|     |___|    |_____|     |_____|           |_____|     |______</pre>
<!-- <pre class="small">                  _____ _____ _____ _____ _____ _____ _____ _____                                                          </pre> -->
<!-- <pre class="small"> MOSI        : --X_____X_____X_____X_____X_____X_____X_____X_____X---------------------------------------------------------</pre> -->
<pre class="small">               ______________________                                ______________________________________________________</pre>
<pre class="small"> CTRL.TE     :                       \______________________________/                                                      </pre>
<pre class="small">               __                                                     _____________________________________________________</pre>
<pre class="small"> FSR.TxEmpty :   \___________________________________________________/                                                     </pre>

   <h3>Режим Target</h3>
   <p>
      Для активации устройства в режиме Target (<b>CFG.SM</b>=b'1) требуется перевести вход <b>ts0_cts_i</b> в состояние b'0.
      В этот момент на выход <b>MISO_o</b> выставляется первый бит передаваемого пакета (в соответствии со значением <b>CFG.TBO</b>).
      Начинается опрос линии <b>SCK_i</b> до момента обнаружения фронта сигнала (в соответствии со значениями фазы и полярности).
      Опрос линии происходит через фильтр с частотой <b>rclk</b> путем выборки из 4 значений, поэтому частота <b>SCK</b> не должна превышать частоту <b>rclk</b>/4.
<!--      Q: if x8 ratio of frequencies?-->
      После обнаружения тактового сигнала происходит установка бита <b>STAT.TIP</b>.
      Сброс бита происходит после 8-го перепада на <b>SCK_i</b> или после установки <b>ts0_cts_i</b> (в зависимости от того, что произойдет раньше).
      Данные сдвигаются последовательно, после сдвига последнего бита байта, происходит чтение нового байта из буфера передатчика.
   </p>
   <p>
      Т.к. через SPI нельзя определить заполнение буфера передатчика, то контроль за этим полностью возложен на пользователя.
   </p>
   <p>
      Перевод <b>ts0_cts_i</b> в состояние b'1 в процессе трансфера приводит к окончанию передачи байта.
      После сброса <b>ts0_cts_i</b> передаваться будет уже следующий байт, прочитанный из <b>fifo_tx</b>.
   </p>

   </body>
</html>
<!--
wire [8*SDRAM_WIDTH-1:0] rdData;
wire rdDataEn;
wire wrDataEn;
reg [8*SDRAM_WIDTH-1:0] wrData;
reg [SDRAM_WIDTH-1:0] wrDataMask;
// Note; to provide data before it is required by the PHY there is necessary to delay all control signals to PHY.
//       except write data itself - data written into FIFO 2 cycles to create single write burst.
//       also, need to align data with burst boundary made inside FIFO
wire [1:0] r_dfi_cke, r_dfi_cs, r_dfi_ras_n, r_dfi_cas_n, r_dfi_we_n, r_dfi_odt, r_dfi_act_n;
wire [3:0] r_dfi_bg;
wire [5:0] r_dfi_bank;
wire [27:0] r_dfi_address;
ehl_cdc
#(
.SYNC_STAGE (1),
.WIDTH(2+2+6+2+2+2+28+2+2+4)
) ac_dly_inst
(
.clk(mctrl_clk),
.reset_n(presetn),
.din ({dfi_cke, dfi_cs, dfi_ras_n, dfi_cas_n, dfi_we_n, dfi_odt, dfi_act_n, dfi_bg, dfi_bank, dfi_address[31:18], dfi_address[13:0]}),
.dout ({r_dfi_cke, r_dfi_cs, r_dfi_ras_n, r_dfi_cas_n, r_dfi_we_n, r_dfi_odt, r_dfi_act_n, r_dfi_bg, r_dfi_bank, r_dfi_address})
);
// Note: parameters to module are not provided as core should be regenerated in case of parameter change
assign sdram_we_n = sdram_a[14];
phy_ddr4 phy_inst
(
.sys_rst (!presetn),
.c0_sys_clk_p (ddr_clk),
.c0_sys_clk_n ( ddr_clk_n),
.c0_ddr_ui_clk_sync_rst (ui_rst),
.c0_ddr4_act_n (sdram_act_n),
.c0_ddr4_adr ({sdram_ras_n, sdram_ca_n, sdram_a}),
.c0_ddr4_ba (sdram_ba[1:0]),
.c0_ddr4_bg (sdram_bg[0]),
.c0_ddr4_cke (sdram_cke),
.c0_ddr4_odt (sdram_odt),
.c0_ddr4_cs_n (sdram_cs_n),
.c0_ddr4_ck_t (sdram_ck),
.c0_ddr4_ck_c (sdram_ck_n),
.c0_ddr4_reset_n (sdram_rst_n),
.c0_ddr4_dm_dbi_n (sdram_dm),
.c0_ddr4_dq (sdram_dq),
.c0_ddr4_dqs_c (sdram_dqs_n),
.c0_ddr4_dqs_t (sdram_dqs),
.c0_init_calib_complete (dfi_init_complete),
.addn_ui_clkout1(mctrl_clk),
.addn_ui_clkout2(slow_clk),
.dBufAdr (5'h0) , // should be tied low
.wrData,
.wrDataMask,
.rdData
.rdDataEn,
.wrDataEn,
.mcCasSlot(2'h0),
.mcCasSlot2(2'h0),
.mcRdCAS ((!r_dfi_cs[0] & r_dfi_ras_n[0] & !r_dfi_cas_n[0] & r_dfi_we_n[0]) | (!r_dfi_cs[1] & r_dfi_ras_n[1] & !r_dfi_cas_n[1] & r_dfi_we_n[1]),
.mcWrCAS ((!r_dfi_cs[0] & r_dfi_ras_n[0] & !r_dfi_cas_n[0] & !r_dfi_we_n[0]) | (!r_dfi_cs[1] & r_dfi_ras_n[1] & !r_dfi_cas_n[1] & !r_dfi_we_n[1]),
.winInjTxn(1'b0),
.winRmw(1'b0),
.gt_data_ready(1'b0),
.winBuf(5'h0),
.winRank(2'd0),
.mc_CKE ( {r_dfi_cke[0], r_dfi_cke[0], // default
           r_dfi_cke[0], r_dfi_cke[0], // default
           r_dfi_cke[1], r_dfi_cke[1],
           r_dfi_cke[0], r_dfi_cke[0]}),
.mc_CS_n ( {2'h3, 2'h3,
           r_dfi_cs_n[1], r_dfi_cs_n[1],
           r_dfi_cs_n[0], r_dfi_cs_n[0]}),
.mc_BA (   {2'h0, 2'h0, r_dfi_bank[4], r_dfi_bank[4], r_dfi_bank[1], r_dfi_bank[1],
            2'h0, 2'h0, r_dfi_bank[3], r_dfi_bank[3], r_dfi_bank[0], r_dfi_bank[0]} ),
.mc_ADR (   {2'h3, 2'h3, r_dfi_ras_n[1], r_dfi_ras_n[1], r_dfi_ras_n[0], r_dfi_ras_n[0],
             2'h3, 2'h3, r_dfi_cas_n[1], r_dfi_cas_n[1], r_dfi_cas_n[0], r_dfi_cas_n[0],
             2'h3, 2'h3, r_dfi_we_n[1], r_dfi_we_n[1], r_dfi_we_n[0], r_dfi_we_n[0],
             2'h0, 2'h0, r_dfi_address[27], r_dfi_address[27], r_dfi_address[13], r_dfi_address[13],
             2'h0, 2'h0, r_dfi_address[26], r_dfi_address[26], r_dfi_address[12], r_dfi_address[12],
             2'h0, 2'h0, r_dfi_address[25], r_dfi_address[25], r_dfi_address[11], r_dfi_address[11],
             2'h0, 2'h0, r_dfi_address[24], r_dfi_address[24], r_dfi_address[10], r_dfi_address[10],
             2'h0, 2'h0, r_dfi_address[23], r_dfi_address[23], r_dfi_address[9], r_dfi_address[9],
             2'h0, 2'h0, r_dfi_address[22], r_dfi_address[22], r_dfi_address[8], r_dfi_address[8],
             2'h0, 2'h0, r_dfi_address[21], r_dfi_address[21], r_dfi_address[7], r_dfi_address[7],
             2'h0, 2'h0, r_dfi_address[20], r_dfi_address[20], r_dfi_address[6], r_dfi_address[6],
             2'h0, 2'h0, r_dfi_address[19], r_dfi_address[19], r_dfi_address[5], r_dfi_address[5],
             2'h0, 2'h0, r_dfi_address[18], r_dfi_address[18], r_dfi_address[4], r_dfi_address[4],
             2'h0, 2'h0, r_dfi_address[17], r_dfi_address[17], r_dfi_address[3], r_dfi_address[3],
             2'h0, 2'h0, r_dfi_address[16], r_dfi_address[16], r_dfi_address[2], r_dfi_address[2],
             2'h0, 2'h0, r_dfi_address[15], r_dfi_address[15], r_dfi_address[1], r_dfi_address[1],
             2'h0, 2'h0, r_dfi_address[14], r_dfi_address[14], r_dfi_address[0], r_dfi_address[0]}),
.mc_ODT (   {r_dfi_odt[1],r_dfi_odt[1],r_dfi_odt[1],r_dfi_odt[1], // default... not really correct one
            r_dfi_odt[0],r_dfi_odt[0],r_dfi_odt[0],r_dfi_odt[0]}),
.mc_ACT_n ( {2'h3, 2'h3, r_dfi_act_n[1], r_dfi_act_n[1], r_dfi_act_n[0], r_dfi_act_n[0]}),
.mc_BG ( {2'h0, 2'h0, r_dfi_bg[2], r_dfi_bg[2], r_dfi_bg[0], r_dfi_bg[0]} )
);

wire rd_empty;
ehl_fifo
#(
.WIDTH_DIN(128),
.WIDTH_DOUT(64)/*,
.SYNC_STAGE(0)*/
)
rd_fifo_inst
(
.wclk(mctrl_clk),
.rclk(mctrl_clk),
.wr (rdDataEn),
.rd(!rd_empty),
.w_reset_n(presetn), //
.wdat ( {
   rdData[15*8+:8],   rdData[7*8+:8],
   rdData[14*8+:8],   rdData[6*8+:8],
   rdData[13*8+:8],   rdData[5*8+:8],
   rdData[12*8+:8],   rdData[4*8+:8],
   rdData[11*8+:8],   rdData[3*8+:8],
   rdData[10*8+:8],   rdData[2*8+:8],
   rdData[9*8+:8],   rdData[1*8+:8],
   rdData[8*8+:8],   rdData[0*8+:8],
}),
.rdata (dfi_rdata),
.r_empty(rd_empty),
.clr_of(1'b0),
.clr_uf(1'b0));
assign dfi_rddata_valid = {4{!rd_empty}};
assign dfi_rdlvl_resp = 0;
wire wr_empty;
wire [128+16-1:0] wdata;
always@(posedge mctrl_clk)
if(wrDataEn & !wr_empty)
begin
wrData <= {
   wdata[8+15*8+:8],   wdata[8+13*8+:8],   wdata[8+11*8+:8],   wdata[8+9*8+:8],   wdata[7*8+:8],   wdata[5*8+:8],   wdata[3*8+:8],   wdata[1*8+:8],
   wdata[8+14*8+:8],   wdata[8+12*8+:8],   wdata[8+10*8+:8],   wdata[8+8*8+:8],   wdata[6*8+:8],   wdata[4*8+:8],   wdata[2*8+:8],   wdata[0*8+:8]};
wrDataMask <= ~{
   wdata[143],   wdata[141],   wdata[139],   wdata[137],   wdata[71],   wdata[69],   wdata[67],   wdata[65],
   wdata[142],   wdata[140],   wdata[138],   wdata[136],   wdata[70],   wdata[68],   wdata[66],   wdata[64]};
};
ehl_fifo
#(
.WIDTH_DIN(64+8),
.WIDTH_DOUT(128+16),
.DEPTH(32),
.SYNC_STAGE(0)
)
wr_fifo_inst
(
.wclk(mctrl_clk),
.rclk(mctrl_clk),
.wr (dfi_wrdata_en[0]),
.rd(wrDataEn & !wr_empry),
.w_reset_n(presetn), //
.wdat ({dfi_wrdata_mask, dfi_wrdata}),
.rdat ( wdat ),
.r_empty(wr_empty),
.clr_of(1'b0),
.clr_uf(1'b0));

-->
