<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Data Buffer</title>
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div class="article">
         <div class="titlepage">
            <h2 class="title">Руководство пользователя ehl_data_buffer</h2>
         </div>
      </div>
      <div class="table">
         <table summary="Reference" cellpadding="4" width="0%" border="1" cellspacing="0" rules="all">
            <colgroup><col><col></colgroup>
            <tbody>
               <tr> <td bgcolor="#C0C0C0">Версия</td>      <td>1.0</td> </tr>
               <tr> <td bgcolor="#C0C0C0">Дата</td>        <td>2017.04.01</td> </tr>
               <tr> <td bgcolor="#C0C0C0">Разработчик</td> <td>А.В. Корнюхин (kornukhin@mail.ru)</td> </tr>
            </tbody>
         </table>
      </div>

      <h2 class="title">Введение</h2>
      <p>При использовании FIFO для синхронизации потока данных внутри одного тактового домена могут возникать временные нарушения в пути данных, как на входах так и на выходах данных FIFO. В случае, когда массив для хранения данных реализован на триггерах (а не на библиотечных модулях статической памяти, что характерно для FIFO небольшого размера), путь данных можно несколько сократить.</p>
      <p>Причиной временных нарушений служит наличие логики и большое разветвление сигналов данных внутри FIFO, а также наличие логики за его пределами. Хотя существует старая (и уже не требуемая) рекомендация к использованию регистровых данных на границе блоков, никто не ограничивает пользователя в выборе конструкций.</p>
      <p>Типичная структура массива данных FIFO представлена на рис. 1. Как видно из рисунка, путь данных от входа D0 проходит через логику, содержащую сигнал разрешения записи и указатель на адрес массива. Путь данных до выхода Q0 формируется на мультиплексоре от всех элементов массива.</p>

      <img src="um_fifo.png"></a>
      <p>Рис. 1. Фрагмент структуры FIFO.</p>

      <p>При наличии временных нарушений на одном из указанных путей, от логики в нем можно избавиться. Цена уменьшения задержки в пути – возросшая мощность.</p>
      <p>При наличии критичного пути на входе FIFO следует выбрать режим записи в первый элемент массива со сдвигом всех уже имеющихся в нем данных (сдвиг делает невозможным реализацию массива на стандартной библиотечной блочной памяти). При этом чтение происходит по указателю, с сохранением логики на выходе (рис. 2). Во входном пути данных не используется указатель адреса, а логика подключается только к первому элементу массива.</p>

      <img src="um_fast_in.png"></a>
      <p>Рис. 2. Буфер с уменьшенными входными задержками.</p>

      <p>При наличии критичного пути на выходе FIFO следует выбрать режим чтения из первого элемента массива, с записью по указателю и сдвигом всего массива при чтении (рис. 3). При этом выходные данные всегда управляются напрямую с выхода первого элемента массива.</p>

      <img src="um_fast_out.png"></a>
      <p>Рис. 3. Буфер с уменьшенными выходными задержками.</p>

      <p>Следует иметь в виду, что поскольку в отличие от реализации FIFO требуется сдвигать весь массив при чтении/записи, то потребляемая мощность возрастает.</p>
      <p>Описанные выше модификации не приводят к изменения окружающего FIFO кода, т.е. делается локальное изменение, имеющее эквивалентный функционал на границе FIFO.</p>

   </body>
</html>
