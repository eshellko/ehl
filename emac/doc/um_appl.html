<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Применение</title>
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<!--
      <h2 class="title">Применение</h2>
      <p><b>DDR_MCTRL</b> реализован с помощью синтезированного подмножества языка Verilog [6]. Вместе с модулем предоставляются временные ограничения в формате Synopsys Design Constraints (SDC) для использования в процессе логического синтеза. Контроллер не содержит примитивов, привязанных к конкретному технологическому процессу. Модули памяти в силу небольшого размера реализованы на триггерах.</p>
      <p><b style="color: #FF0000">Замечание</b>. Если не требуется поддержки 35-битного адресного пространства, то старшие биты адреса <b>awaddr</b>/<b>araddr</b> могут быть подключены к логическому 0. В этом случае неиспользуемая логика будет удалена в процессе синтеза. </p>
      <p><b style="color: #FF0000">Замечание</b>. Если ширина интерфейса AXI равна 32 или 64, то старшие биты <b>arsize</b> и <b>awsize</b> следует подключить к 0b0 для сокращения количества логики.</p>
      <p><b style="color: #FF0000">Замечание</b>. Если контроллер предназначен для работы с трансферами определенного размера, например, AXI 32 бита, то соответствующее ему значение следует установить на входах <b>awsize</b>/<b>arsize</b>.</p>
      <p><b style="color: #FF0000">Замечание</b>. Если применение требует использования ограниченного количества режимов, то соответствующие режимам конфигурационные регистры могут быть заменены на константы (вручную в RTL или скриптом при синтезе). Например, если обращения к SDRAM должны поддерживать только транзакции с Burst Length, равной 8, то следует заменить <b>DDR2_MR.BL</b>[0] на 0b1. Другие примеры - использование ограниченного набора значений CAS Latency может позволить заменить биты <b>DDR2_MR.CL</b> на константы; поддержка ограниченного набора структур памяти (например, если не требуется поддерживать память с 8 банками, можно использовать set_logic_zero ddr2c_inst/cmd_queue_inst/addr_dec_load_inst/bank_mask и set_logic_zero ddr2c_inst/cmd_queue_inst/addr_dec_update_inst/bank_mask) позволяет сократить логику декодера адреса.</p>
      <h3 style="color: #0000CC">Система доменов синхросигналов</h3>
      <p>Все регистры, находящиеся на пересечении доменов тактовых сигналов (первые триггеры в синхронизаторах) специфицированы в Таблица 27. Эти триггеры следует исключить из генерации 'X' при возникновении на них временных нарушений при моделировании с SDF. Если все тактовые домены <b>DDR_MCTRL</b> синхронны между собой и параметр <b>CDC_SYNC_STAGE</b> равен 0, то указанные в Таблица 27 регистры не следует исключать из проверки временных нарушений при моделировании. Имена регистров могут отличаться в зависимости от настроек синтезатора. В таблице представлен наиболее распространенный стиль переименования в формате %s_reg.</p>
      <p><b style="color: #FF0000">Замечание</b>. Данная таблица приведена в качестве справочной информации, актуальный перечень можно увидеть в начале отчета моделирования.</p>
      <table summary="sync" cellpadding="4" width="60%" border="1" cellspacing="0" rules="all">
         <colgroup><col><col><col></colgroup>
         <thead>
            <tr bgcolor="#C0C0C0">
               <th>Иерархический путь</th>
               <th>Домен данных</th>
               <th>Домен регистра</th>
            </tr>
         </thead>
         <tbody>
            <tr> <td>axi_mux_inst/wfifo_ctrl_inst/rptr_cdc/shift_reg[0][*]</td> <td>mctrl_clk</td> <td>aclk</td> </tr>
            <tr> <td>axi_mux_inst/wfifo_ctrl_inst/wptr_cdc/shift_reg[0][*]</td> <td>aclk</td> <td>mctrl_clk</td> </tr>
            <tr> <td>axi_mux_inst/wfifo_data_inst/rptr_cdc/shift_reg[0][*]</td> <td>mctrl_clk</td> <td>aclk</td> </tr>
            <tr> <td>axi_mux_inst/wfifo_data_inst/wptr_cdc/shift_reg[0][*]</td> <td>aclk</td> <td>mctrl_clk</td> </tr>
            <tr> <td>axi_mux_inst/wfifo_cmds_inst/rptr_cdc/shift_reg[0][*]</td> <td>mctrl_clk</td> <td>aclk</td> </tr>
            <tr> <td>axi_mux_inst/wfifo_cmds_inst/wptr_cdc/shift_reg[0][*]</td> <td>aclk</td> <td>mctrl_clk</td> </tr>
            <tr> <td>axi_mux_inst/wfifo_resp_inst/rptr_cdc/shift_reg[0][*]</td> <td>aclk</td> <td>mctrl_clk</td> </tr>
            <tr> <td>axi_mux_inst/wfifo_resp_inst/wptr_cdc/shift_reg[0][*]</td> <td>mctrl_clk</td> <td>aclk</td> </tr>
            <tr> <td>axi_mux_inst/rfifo_ctrl_inst/rptr_cdc/shift_reg[0][*]</td> <td>mctrl_clk</td> <td>aclk</td> </tr>
            <tr> <td>axi_mux_inst/rfifo_ctrl_inst/wptr_cdc/shift_reg[0][*]</td> <td>aclk</td> <td>mctrl_clk</td> </tr>
            <tr> <td>axi_mux_inst/rfifo_data_inst/rptr_cdc/shift_reg[0][*]</td> <td>aclk</td> <td>mctrl_clk</td> </tr>
            <tr> <td>axi_mux_inst/rfifo_data_inst/wptr_cdc/shift_reg[0][*]</td> <td>mctrl_clk</td> <td>aclk</td> </tr>
            <tr> <td>csr_inst/bus_sync_inst/sync_ahb_req_wr_inst/shift_reg[0][0]</td> <td>hclk</td> <td>mctrl_clk</td> </tr>
            <tr> <td>csr_inst/bus_sync_inst/sync_ahb_req_rd_inst/shift_reg[0][0]</td> <td>hclk</td> <td>mctrl_clk</td> </tr>
            <tr> <td>csr_inst/bus_sync_inst/sync_ahb_done_wr_inst/shift_reg[0][0]</td> <td>mctrl_clk</td> <td>hclk</td> </tr>
            <tr> <td>csr_inst/bus_sync_inst/sync_ahb_done_rd_inst/shift_reg[0][0]</td> <td>mctrl_clk</td> <td>hclk</td> </tr>
            <tr> <td>csr_inst/ifg.sync_interrupt_inst/shift_reg[0][0] **</td> <td>mctrl_clk</td> <td>hclk</td> </tr>
            <tr> <td>ddr2c_inst/sync_inst/shift_reg[0][75:0]</td> <td>aclk</td> <td>mctrl_clk</td> </tr>
         </tbody>
      </table>
      <p>* Количество триггеров в синхронизированных счетчиках Грея зависит от глубины FIFO и соотношения ширины портов данных записи и чтения.</p>
      <p>** Присутствует в конфигурации с корректирующим кодом.</p>
      <p>Для исключения ложных ошибок при моделировании схемы с SDF рекомендуется следовать инструкции:</p>
      <p>1. Во время моделирования при нарушении требований setup/hold на триггере-приемнике, располагающемся на границе асинхронных тактовых доменов, будет генерироваться сообщение о временном нарушении, а сам триггер будет переключаться в состояние 0bx.</p>
      <p>2. Контроллер содержит 2 типа триггеров на границе доменов - флаги-синхронизаторы и данные <b>(todo: Добавить таблицу с перечнем указанных регистров. Третий тип - данные, захватываемые в момент стабильности.)</b>.</p>
      <p>a. Флаги-синхронизаторы имеют CDC_SYNC_STAGE последовательно подключенных триггеров. При возникновении метастабильности на первом, следующие будут минимизировать этот эффект.</p>
      <p>b. Триггеры данных будут переходить в неопределенное состояние при возникновении временных нарушений, но логика контроллера устроена таким образом, что данные будут обновлены на следующем такте корректным значением и не будут читаться, когда значение неопределенно.</p>
      <p>3. В случае 2.а требуется отключить проверку setup/hold при моделировании и считать, что схема синхронизации корректирует любую возникшую ошибку.</p>
      <p>4. В случае 2.б проверку временных нарушений можно оставить, или исключить. В первом случае следует предусмотреть возможность фильтрации сообщений об ошибках, чтобы не пропустить нарушения от источников, являющихся потенциально критичными.</p>
      <p>5. Исключить триггер из проверки можно следующими способами (способы могут меняться в зависимости от используемых САПР):</p>
      <p>a. Выгрузить SDF и netlist для моделирования с задержками. По умолчанию SDF будет содержать проверки и на путях, относящихся к схемам переключения между тактовыми доменами.</p>
      <p>b. В случае с 2.а для первого триггера в синхронизаторе (Таблица 27) следует деактивировать проверку. Деактивация может быть выполнено вручную (или с помощью скрипта) в SDF, или автоматически в САПР. В случае с 2.б деактивация может (но не должна) быть выполнена для снижения количества сообщений о временных нарушениях при моделировании.</p>
      <p>c. Деактивация с помощью обнуления проверки выполняется командой set_annotated_check. После выполнения команд следует выгрузить SDF командой write_sdf.</p>
      <p>set_annotated_check 0 -from sync_reg[0]/CP -to sync_reg[0]/D -setup</p>
      <p>set_annotated_check 0 -from sync_reg[0]/CP -to sync_reg[0]/D -hold</p>
      <p>d. Деактивация с помощью удаления проверки выполняется командой set_disable_timing. После выполнения команд следует выгрузить SDF командой write_sdf -exclude_disabled_arcs.</p>
      <p>set_disable_timing -from CP -to D sync_reg[0]</p>
      <p><b style="color: #FF0000">Замечание</b>. Следует иметь в виду, что имена пинов (D и CP) могут отличаться для различных библиотек.</p>
      <h3 style="color: #0000CC">Модули памяти</h3>
      <p><b>DDR_MCTRL</b> позволяет использовать модули блочной двухпортовой памяти (1 порт записи, 1 порт чтения) для сокращения количества используемой логики. Пользователь может использовать блоки памяти, или реализовать контроллер с помощью триггеров. В ПЛИС синтезатор, обычно, автоматически определяет память и заменяет ее доступными ресурсами. Выбор реализации производится с помощью параметра <b>RAM_TECHNOLOGY</b>. Значение 0 (по умолчанию) приводит к реализации блоков памяти на триггерах. Другие значения приводят к попытке реализовать память с помощью библиотечных элементов. Если требуемая конфигурация памяти отсутствует в ehl_spram, память будет заменена на генератор константы 0b0, а в консоль при моделировании будет выведено сообщение о том, что память заменена на "черный ящик".</p>
      <table summary="rams" cellpadding="4" width="90%" border="1" cellspacing="0" rules="all">
         <colgroup><col><col><col><col><col><col></colgroup>
         <thead>
            <tr bgcolor="#C0C0C0">
               <th>Иерархический путь</th>
               <th>Кол-во слов</th>
               <th>Размер слова</th>
               <th>Назначение</th>
               <th>Синхросигнал</th>
               <th>Конфигурация</th>
            </tr>
         </thead>
         <tbody>
            <tr> <td>ddr2c_inst/rd_inst/ram.ram_inst</td> <td>2 * <b>SDRAM_WIDTH</b>+1</td> <td>32</td> <td>Буфер чтения</td> <td>mctrl_clk</td> <td><b>HDR_MODE</b> = 0</td> </tr>
            <tr> <td>ddr2c_inst/rd_inst/ram.ram_inst</td> <td>4 * <b>SDRAM_WIDTH</b>+1</td> <td>32</td> <td>Буфер чтения</td> <td>mctrl_clk</td> <td><p><b>HDR_MODE</b> = 1</p><b>AXI_WIDTH</b>/<b>SDRAM_WIDTH</b> = 4<p></p></td> </tr>
            <tr> <td>ddr2c_inst/rd_inst/ram.ram_even_inst</td> <td>2 * <b>SDRAM_WIDTH</b>+1</td> <td>16</td> <td>Буфер чтения</td> <td>mctrl_clk</td> <td><p><b>HDR_MODE</b> = 1</p><b>AXI_WIDTH</b>/<b>SDRAM_WIDTH</b> != 4<p></p></td> </tr>
            <tr> <td>ddr2c_inst/rd_inst/ram.ram_odd_inst</td> <td>2 * <b>SDRAM_WIDTH</b>+1</td> <td>16</td> <td>Буфер чтения</td> <td>mctrl_clk</td> <td><p><b>HDR_MODE</b> = 1</p><b>AXI_WIDTH</b>/<b>SDRAM_WIDTH</b> != 4<p></p></td> </tr>
         </tbody>
      </table>
      <h3 style="color: #0000CC">Используемые ресурсы</h3>
      <p><b>DDR_MCTRL</b> синтезирован в базисе технологических библиотек для оценки требуемых ресурсов и достижимых тактовых частот.</p>
      <table summary="resources" cellpadding="4" width="50%" border="1" cellspacing="0" rules="all">
         <colgroup><col><col><col><col><col><col><col></colgroup>
         <thead>
            <tr bgcolor="#C0C0C0">
               <th>Параметр</th>
               <th>Требование</th>
               <th>Mikron RT 90nm</th>
               <th>Mikron RT 90nm</th>
               <th>Mikron RT 90nm</th>
               <th>Mikron RT 90nm</th>
               <th>Единица измерения</th>
            </tr>
         </thead>
         <tbody>
            <tr> <td>Тактовая частота SDRAM FSDRAM</td> <td>125 - 400</td> <td>400</td> <td>400</td> <td>400</td> <td>400</td> <td>МГц</td> </tr>
            <tr> <td>Тактовая частота AHB FAHB</td> <td>50 - 200</td> <td>200</td> <td>200</td> <td>200</td> <td>200</td> <td>МГц</td> </tr>
            <tr> <td>Тактовая частота AXI FAXI</td> <td>50 - 400</td> <td>400</td> <td>400</td> <td>400</td> <td>400</td> <td>МГц</td> </tr>
            <tr> <td>Количество выводов</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr>
            <tr> <td>Количество триггеров</td> <td></td> <td>11719</td> <td>6821</td> <td>4002</td> <td>11183</td> <td></td> </tr>
            <tr> <td>Количество блоков памяти</td> <td></td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td></td> </tr>
            <tr> <td>Количество логических вентилей</td> <td></td> <td>27644</td> <td>16259</td> <td>10377</td> <td>26411</td> <td></td> </tr>
            <tr> <td>Тестовое покрытие ATPG Stuck-at</td> <td>99 - 100</td> <td>100.00</td> <td>100.00</td> <td>100.00</td> <td>100.00</td> <td>%</td> </tr>
            <tr> <td>Параметры</td> </tr>
            <tr> <td>AXI_WIDTH</td> <td></td> <td>128</td> <td>64</td> <td>32</td> <td>128</td> <td></td> </tr>
            <tr> <td>SDRAM_WIDTH</td> <td></td> <td>64</td> <td>32</td> <td>8</td> <td>64</td> <td></td> </tr>
            <tr> <td>ECC_ENA</td> <td></td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td></td> </tr>
            <tr> <td>RANK_CNT</td> <td></td> <td>2</td> <td>1</td> <td>1</td> <td>2</td> <td></td> </tr>
            <tr> <td>AXI_QUEUE_DEPTH</td> <td></td> <td>2</td> <td>2</td> <td>2</td> <td>2</td> <td></td> </tr>
            <tr> <td>ERROR_FIFO_DEPTH</td> <td></td> <td>4</td> <td>4</td> <td>4</td> <td>0</td> <td></td> </tr>
            <tr> <td>CDC_SYNC_STAGE</td> <td></td> <td>2</td> <td>2</td> <td>2</td> <td>2</td> <td></td> </tr>
            <tr> <td>SYNCHRONIZE_RESETS</td> <td></td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td></td> </tr>
            <tr> <td>RAM_ADDR</td> <td></td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td></td> </tr>
            <tr> <td>REGISTER_RDDATA</td> <td></td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td></td> </tr>
            <tr> <td>AXI_4K_LIMIT</td> <td></td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td></td> </tr>
         </tbody>
      </table>
      <h3 style="color: #0000CC">Пропускная способность контроллера</h3>
      <p>Пропускная способность <b>DDR_MCTRL</b> зависит от множества факторов, таких как: тактовая частота AXI, тактовая частота MCTRL, Burst Length, Refresh Period, CAS Latency, Additive Latency, соотношение ширины интерфейсов AXI и SDRAM.</p>
      <p>В общем случае наблюдаемые значения максимальной пропускной способности, полученные для набора тестов, представлены в таблице (результаты представлены для двух значений недокументированного параметра <b>IMPL_SLOW_AXI_RD</b>). Значение вычисляется как отношение скорости передачи через DFI к минимальной (лимитирующей) из скоростей AXI и DFI.</p>
      <table summary="bandwidth" cellpadding="4" width="40%" border="1" cellspacing="0" rules="all">
         <colgroup><col><col><col><col><col></colgroup>
         <thead>
            <tr bgcolor="#C0C0C0">
               <th></th>
               <th>Мин.</th>
               <th>Макс.</th>
               <th>Мин.</th>
               <th>Макс.</th>
            </tr>
         </thead>
         <tbody>
            <tr> <td>IMPL_SLOW_AXI_RD</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> </tr>
            <tr> <td>Запись, BL = 4</td> <td>94.32 %</td> <td>99.38 %</td> <td>94.40 %</td> <td>99.38 %</td> </tr>
            <tr> <td>Запись, BL = 8</td> <td>89.84 %</td> <td>99.38 %</td> <td>89.84 %</td> <td>99.38 %</td> </tr>
            <tr> <td>Чтение, BL = 4</td> <td>79.25 %</td> <td>95.20 %</td> <td>90.00 %</td> <td>95.27 %</td> </tr>
            <tr> <td>Чтение, BL = 8</td> <td>79.25 %</td> <td>98.88 %</td> <td>90.53 %</td> <td>98.88 %</td> </tr>
         </tbody>
      </table>
      <h3 style="color: #0000CC">Диагностика неисправностей</h3>
      <p>При отладке контроллера могут возникнуть проблемы, связанные со сложностями реализации протокола DDR. Далее приведен перечень действий по поиску причины неисправностей.</p>
      <table summary="bandwidth" cellpadding="4" width="100%" border="1" cellspacing="0" rules="all">
         <colgroup><col><col><col></colgroup>
         <thead>
            <tr bgcolor="#C0C0C0">
               <th>Симптом</th>
               <th>Причина</th>
               <th>Пути устранения</th>
            </tr>
         </thead>
         <tbody>
            <tr> <td>Зависание системы</td> <td>Отсутствие откликов от контроллера на системной шине. Ожидается, что контроллер шины обрабатывает ситуации долгих откликов от ведомых устройств на шине в соответствии с конфигурацией системы, т.е. независимо от IP используемых в системе.</td> <td>При отсутствии синхросигнала <b>mctrl_clk</b> контроллер будет принимать транзакции AXI и AHB, но не будет отвечать на них. В случае с AHB сигнал <b>hready</b> будет переведен в состояние 0, в случае с AXI не будет откликов по Read Response и Write Response Channel. Следует убедиться, что PHY пропускает корректную опорную частоту через DLL. При наличии данной неисправности в PHY контроллер не подлежит к использованию.</td> </tr>
            <tr> <td></td> <td></td> <td>Некорректные результаты тренингов могут привести к генерации ложных стробов или маскированию ожидаемых стробов при чтении из памяти. В этом случае следует сбросить контроллер и провести тренинги вручную.</td> </tr>
            <tr> <td>Нестабильная работа контроллера</td> <td>Регулярное возникновение ошибок в данных, некорректные значения регистров...</td> <td>При отсутствии повторяемости результатов на нескольких образцах, следует убедиться, что DFT тесты не выявляют производственных дефектов. Компоненты с дефектами следует исключить из использования.</td> </tr>
            <tr> <td></td> <td></td> <td>При наличии ошибок в данных следует включить режим коррекции ошибок кодом Хэмминга. Если корректирующей способности кода не достаточно, следует исключить образец из использования.</td> </tr>
            <tr> <td></td> <td></td> <td>При регулярном наличии ошибок следует проверить, что линии данных к памяти выровнены между собой. При обнаружении источника ошибок следует изменить топологию печатной платы.</td> </tr>
            <tr> <td></td> <td></td> <td>Проверить значение <b>DDR2_GTR.DRV</b>. Если значение отлично от нуля, это указывает на невыровненность стробов и большую задержку в линии стробов по сравнению с линией синхросигналов. Следует проверить повторяемость результатов на меньшей частоте <b>mctrl_clk</b> из рабочего диапазона контроллера. Если ошибка пропадает при понижении частоты, это может свидетельствовать о несбалансированности стробов и синхрсоигналов.</td> </tr>
            <tr> <td></td> <td></td> <td>Нестабильная частота <b>mctrl_clk</b> может приводить к сбоям в обработке данных. Следует убедиться, что <b>DDR2_PHY.DL</b> равен 1 перед началом работы с PHY.</td> </tr>
         </tbody>
      </table>
      <h3 style="color: #0000CC">Тестовое покрытие</h3>
      <p>Для верификации <b>DDR_MCTRL</b> используется тест elvs_ddr2_tb. В зависимости от выбранной конфигурации контроллера он имеет различное тестовое покрытие. В таблице представлено значение для различных видов тестового покрытия для некоторых конфигураций.</p>
      <table summary="coverage" cellpadding="4" width="60%" border="1" cellspacing="0" rules="all">
         <colgroup><col><col><col><col></colgroup>
         <thead>
            <tr bgcolor="#C0C0C0">
               <th>Тип покрытия</th>
               <th></th>
               <th></th>
               <th></th>
            </tr>
         </thead>
         <tbody>
            <tr> <td>block</td>        <td>1790 / 1907 (94%)</td> <td>1806 / 1907 (95%)</td> <td>1833 / 1929 (95%)</td> </tr>
            <tr> <td>expression</td>   <td>136 / 160 (85%)</td> <td>138 / 160 (86%)</td> <td>140 / 160 (87%)</td> </tr>
            <tr> <td>toggle</td>       <td>12013 / 14151 (85%)</td> <td>12254 / 14388 (85%)</td> <td>14244 / 16238 (88%)</td> </tr>
            <tr> <td>Конфигурация</td> <td><p>AXI_WIDTH = 32</p><p>AXI_QUEUE_DEPTH = 2</p><p>DDR2-533</p><p>SDRAM_WIDTH = 8</p><p>ECC_ENA = 1</p><p>AXI 400 MHz</p><p>AHB 167 MHz</p></td> <td><p>AXI_WIDTH = 32</p><p>AXI_QUEUE_DEPTH = 4</p><p>DDR2-533</p><p>SDRAM_WIDTH = 8</p><p>ECC_ENA = 1</p><p>AXI 400 MHz</p><p>AHB 167 MHz</p></td> <td><p>AXI_WIDTH = 64</p><p>AXI_QUEUE_DEPTH = 4</p><p>DDR2-533</p><p>SDRAM_WIDTH = 16</p><p>ECC_ENA = 1</p><p>AXI 400 MHz</p><p>AHB 167 MHz</p></td> </tr>
         </tbody>
      </table>
      <p></p>-->
   </body>
</html>
