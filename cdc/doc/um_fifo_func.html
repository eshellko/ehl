<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Функционирование</title>
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
     <div class="article">
         <div class="titlepage">
            <h2 class="title">Функционирование</h2>
         </div>
      </div>

      <p>Т.к. ширина входных и выходных данных может отличаться, то ширина ячейки буфера является минимальной из ширин входных и выходных данных. Если ширина входных данных больше ширины выходных, то за 1 процедуру записи происходит заполнение нескольких ячеек памяти. Если ширина выходных данных больше ширины входных, то за 1 процедуру чтения происходит опустошение нескольких ячеек памяти.</p>
      <p><b>Запись буфера</b></p>
      <p>Запись данных с <b>wdat</b> осуществляется при <b>wr</b>=0b1, если <b>w_full</b>=0b0 на нарастающем фронте <b>wclk</b>. Одновременно происходит инкремент адреса записи буфера.</p>
      <p><b>Ошибка записи буфера</b></p>
      <p>Флаг ошибки записи в буфер <b>w_overflow</b> выставляется при попытке записи в заполненный буфер, т.е. если одновременно <b>w_full</b>=0b1 и <b>wr</b>=0b1, на нарастающем фронте <b>wclk</b>. При возникновении ошибки записи, данные записываемые в буфер теряются. Блок остается в рабочем состоянии и может использоваться без дополнительных действий. Для сброса флага <b>w_overflow</b> нужно установить <b>clr_of</b>.</p>
      <img src="um_fifo_overflow.png">
      <p><b>Чтение буфера</b></p>
      <p>Чтение данных осуществляется при <b>rd</b>=0b1 и <b>r_empty</b>=0b0. Данные из буфера (на выходе <b>rdat</b>) должны быть захвачены до следующего нарастающего фронта <b>rclk</b> (на котором происходит инкремент адреса чтения буфера) после установки <b>rd</b>.</p>
      <p><b>Ошибка чтения буфера</b></p>
      <p>Ошибка чтения буфера происходит при попытке прочитать пустой буфер (<b>rd</b>=0b1 и <b>r_empty</b>=0b1) на нарастающем фронте <b>rclk</b>. При этом происходит выставление флага <b>r_underflow</b>. Блок остается в рабочем состоянии и может использоваться без дополнительных действий. Для сброса флага <b>r_underflow</b> нужно установить <b>clr_uf</b>.</p>
      <img src="um_fifo_underflow.png">
      <p><b>Флаги</b></p>
      <p>Флаг заполненности буфера <b>w_full</b> выставляется, если количество свободных ячеек в буфере меньше, чем количество записываемых за 1 процедуру записи ячеек. Флаг <b>w_afull</b> устанавливается, если в <b>ehl_fifo</b> может быть записано еще одно значение.</p>
      <p>Установка флага w_full. <b>WIDTH_DIN</b>=<b>WIDTH_DOUT</b>=8, <b>DEPTH</b>=8. <b>SYNC_STAGE</b>=1:</p>
      <img src="um_fifo_ex1.png">
      <p>Флаг опустошения буфера <b>r_empty</b> выставляется, если количество заполненных ячеек в буфере меньше, чем количество читаемых за 1 процедуру чтения ячеек. Флаг <b>r_aempty</b> устанавливается, если из <b>ehl_fifo</b> может быть прочитано еще одно значение.</p>
      <p>Установка флага empty. <b>WIDTH_DIN</b>=<b>WIDTH_DOUT</b>=8, <b>DEPTH</b>=8. <b>SYNC_STAGE</b>=1:</p>
      <img src="um_fifo_ex2.png">

      <p><b>Синхронизация wclk и rclk</b></p>
      <p>Интерфейсы записи и чтения буфера работают на собственных тактовых частотах <b>wclk</b> и <b>rclk</b>. Тактовые сигналы могут быть асинхронны друг другу. Передача данных между доменами синхросигналов происходит при формировании флагов <b>w_full</b> / <b>w_empty</b> и <b>r_full</b> / <b>r_empty</b>. Флаги заполненности <b>w_full</b> и опустошенности <b>w_empty</b> формируются в блоке <b>ehl_fifo_wc</b>. Для их формирования используется адрес записи и синхронизованная копия адреса чтения. Из этого следует:</p>
      <li> установка флага <b>w_full</b> происходит сразу после заполнения буфера, а сброс через несколько тактов <b>wclk</b> после того, как он перестает быть заполненным (количество тактов определяется параметром <b>SYNC_STAGE</b>). Аналогично для <b>w_afull</b>.</li>
      <li> сброс флага <b>w_empty</b> происходит сразу после записи в буфер, а установка через несколько тактов <b>wclk</b> после того, как буфер перестает быть свободным (количество тактов определяется параметром <b>SYNC_STAGE</b>). Аналогично для <b>w_aempty</b>.</li>
      <p>Установка флагов full/empty при записи в буфер. <b>WIDTH_DIN</b>=<b>WIDTH_DOUT</b>=8, <b>DEPTH</b>=8. <b>SYNC_STAGE</b>=2:</p>
      <img src="um_fifo_ex3.png">
      <p>Флаги заполненности <b>r_full</b> и опустошенности <b>r_empty</b> формируются в блоке <b>ehl_fifo_rc</b>. Для их формирования используются адрес чтения и синхронизованная копия адреса записи. Из этого следует:</p>
      <li> установка флага <b>r_empty</b> происходит сразу после опустошения буфера, а сброс через несколько тактов <b>rclk</b> после того, как буфер перестает быть пустым (количество тактов определяется параметром <b>SYNC_STAGE</b>). Аналогично для <b>r_aempty</b>.</li>
      <li> сброс флага <b>r_full</b> происходит сразу после того, как буфер перестает быть полным, а установка через несколько тактов <b>rclk</b> после того, как буфер заполнится (количество тактов определяется параметром <b>SYNC_STAGE</b>). Аналогично для <b>r_afull</b>.</li>
      <p>Установка флагов full/empty при чтении буфера. <b>WIDTH_DIN</b>=<b>WIDTH_DOUT</b>=8, <b>DEPTH</b>=8. <b>SYNC_STAGE</b>=2:</p>
      <img src="um_fifo_ex4.png">
      <p>Синхронизованные копии адресов используются во избежание проблем с метастабильностью. Они формируются путем применения сдвигового регистра, количество сдвигов (стадий синхронизации) в котором определяется пользователем (см. параметр <b>SYNC_STAGE</b>).</p>
      <p>Для исключения влияния неодновременности захвата адреса при передаче между доменами синхросигналов используется код Грэя. В момент захвата может переключаться не более 1 бита адреса. В результате может быть захвачено одно из двух значений адреса: текущее или предыдущее. Таким образом, ошибки с определением адреса не возникнет, может лишь появиться задержка на 1 такт при формировании флагов <b>w_full</b>, <b>w_empty</b>, <b>r_empty</b> и <b>r_full</b> (и almost флагов).</p>
      <p>Количество стадий синхронизации должно выбираться из следующих соображений:</p>
      <li> 0 - если интерфейсы чтения и записи имеют одну частоту (и фазу) - синхронизации не требуется,</li>
      <li> 1 - одна стадия синхронизации может быть применена на относительно малых тактовых частотах, когда времени между нарастающими фронтами захватывающего синхросигнала достаточно, чтобы данные на выходе первой стадии стабилизировались.</li>
      <li> 2 - две стадии синхронизации могут применяться на относительно высоких тактовых частотах. Синхронизация даёт 1 период тактовой частоты для стабилизации выходного сигнала первой стадии перед захватом данных второй стадией. При этом методе синхронизации возрастает задержка между состоянием флагов в сравнении с реальным состоянием буфера (см. примеры выше).</li>
      <li> 3 - три стадии синхронизации могут применяться на высоких тактовых частотах. Синхронизация даёт 1 период тактовой частоты для стабилизации выходного сигнала первой стадии перед захватом данных второй стадией и 1 период тактовой частоты для стабилизации данных с выхода второй стадии до захвата третьей стадией. При этом методе синхронизации возрастает задержка между состоянием флагов в сравнении с реальным состоянием буфера (см. рисунок 8).</li>
      <p>Задержка синхронизации при формировании флагов full и empty. SYNC_STAGE = 1 (<b style="color: #0000CC">синий</b>), 2 (<b style="color: #CC0000">красный</b>), 3 (<b style="color: #FF8000">оранжевый</b>):</p>
      <img src="um_fifo_ex5.png">
      <p><b>Порядок следования данных</b></p>
      <p>Если ширины входных и выходных данных равны, то первым читается первое записанное значение. Если ширина входных данных больше ширины выходных, то первым читаются младшие разряды записанного значения.</p>
      <p>Порядок следования бит. <b>WIDTH_DIN</b>=16, <b>WIDTH_DOUT</b>=8:</p>
      <img src="um_fifo_ex6.png">
      <p>Если ширина выходных данных больше ширины входных, то первое записанное значение читается в младших разрядах.</p>
      <p>Порядок следования бит. <b>WIDTH_DIN</b>=8, <b>WIDTH_DOUT</b>=16:</p>
      <img src="um_fifo_ex7.png">

   </body>
</html>
